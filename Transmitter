#include <SPI.h>                            //this library let microcontrollers communicate with each other quickly over short distances(MISO-send data to master from slave)(MOSI-send data from master to peripherals)(SCK-serial clock,clock pulses which synchronize data transmission generated by the master) 
#include <RF24.h>                           //NRF24 Library: https://github.com/TMRh20/RF24
#include <nRF24L01.h>                       //NRRF24 pin layout: UNO:  MOSI(pin11)MISO(pin12)SCK(pin13)(CE,CSN any pin; defined below)    
#include <printf.h>                         //                   MEGA: MOSI(pin51)MISO(pin50)SCK(pin52)(CE,CSN any pin; defined below)
#include <RF24_config.h>
#define CE_PIN   8
#define CSN_PIN  53
RF24 radio(CE_PIN, CSN_PIN);                //connecting the CE CSN pins
const uint64_t pipe = 0xE8E8F0F0E1LL;       //creating an address (or name) for a "pipe" which the 2 transcievers will communicate inside

#include <Wire.h>
#include <LiquidCrystal_I2C.h>              //LCD library: http://www.sunfounder.com/wiki/index.php?title=File:LiquidCrystal_I2C.zip
LiquidCrystal_I2C lcd(0x27, 20, 4);         //setting display to 0x27 address; 20 columns, 4 rows;  UNO:SDA(A4)SCL(A5); MEGA:SDA(pin20)SCL(pin21)

#define leftStick_x     A0                  //we are only going to use the left x, and right y joysticks for racing (not sure if we are even going to use the left x) but we might need to use them all for other modes.     
#define leftStick_y     A1
#define rightStick_x    A3
#define rightStick_y    A2
#define motorSpeed_Pot  A5
int left_sw  = 22;                          //declaring all the switches we r using
int right_sw = 23;
int lifting_sw   = 44;                      //LIFTING  = 1 -> ACTIVATES leveling potentiometer  |  Change the pins of the first few switches
int throwing_sw  = 45;                      //THROWING = NEED MORE INFORMATION
int climbing_sw  = 43;                      //CLIMBING = NO NEED?
int hitting_sw   = 14;                      //HITTING  = 1 -> ACTIVATES level potentiometer; disables sticks
int STOP_sw      = 41;                      //Emergency STOP; break switch for all motors; MOST IMPORTANT SWITCH! will give all ESCS neutral pulse (a stoping pulse basically)(is need if the joysticks go unstable while its running or something just in case)
int levelUP_sw   = 15;                      //buttons for lifting mode, pressing UP will make the DC motor go forward(bring scissor lift up), DOWN will make the DC motor reverse(bring scissor lift down) 
int levelDOWN_sw = 16;
const int sizeOfArray = 9;
int switchModeArray[] = {left_sw, right_sw, lifting_sw, throwing_sw, climbing_sw, hitting_sw, STOP_sw, levelUP_sw, levelDOWN_sw};
int buttonstateArray[sizeOfArray] = {};
int counter = 0;                            //ignore this for now

struct controllerData {                                                 //making a data structure that will be sent out to the reciever, we will store stuff in this 'package'
  int ESC0; int ESC_1; int ESC_2; int ESC_3; int ESC_4; int ESC_5; int ESC_6; //final ESC Values  for each of the 6 motors that will be sent to the reciever,the final outputs will be changed in the 'if statements' section
  int motorSpeed_Pot;
  bool levelUP_sw;
  bool levelDOWN_sw;
  bool left_sw;
  bool right_sw;
  bool lifting_sw;
  bool throwing_sw;
  bool climbing_sw;
  bool hitting_sw;
  bool STOP_sw;
}; controllerData data;                               //If we type "data.STOP_sw", we can then access the 'packet' called "STOP_sw", which is inside the structure data 'package' called "controllerData" (thats how i understand it anyways)

void setup() {
  Serial.begin(250000);
  Serial.println("Starting");
  radio.begin();                                      //Begin the Radio. the NRF Transciever is above most WiFi routers (the ones that use the 2.4GHZ band anyways). this transciever has a range from 2.4GHz to 2.525GHz. so it basically has 124 channels we can use. We dont need to state the specific channels we want to use since this library takes care of it (i think lol). This page got more info: https://arduino-info.wikispaces.com/Nrf24L01-2.4GHz-HowTo 
  radio.setPALevel(RF24_PA_MAX);                      //set the power consumption
  radio.setDataRate(RF24_250KBPS);                    //set the speed
  radio.setRetries(15, 15);                           //it tkes about 4000microseconds to retry a connection, here we are setting the minimum # of retries to try to make to 15 before writing "connection lost". 15 retries will be about 60mill microseconds or something b4 it gives up . basically it sets the maximum amount of retries before it gives up.
  radio.openWritingPipe(pipe);                        //opening the pipe for writing only
  lcd.init();                                         //Initiate the lcd
  lcd.backlight();                                    //Initiate the backlight
  lcd.clear();                                        //clear the LCD
  for (int i = 0; i < sizeOfArray; i++) {
    pinMode(switchModeArray[i], INPUT);               //Connect all the switch pins to INPUT
    pinMode(switchModeArray[i], INPUT_PULLUP);        //Active the pullup resistors, gives it a little bit more resistance,sometimes the arduino puts the switches as being pushed when u wave ur hand on top of the AtMEGA chip. this makes it so it hae to be be supplied with 5Volts/HIGH (being pushed) to register a 1
  }
  
}//END OF SETUP
 
//Just makeing some more global varibles that we gana use in the loop and other functions
bool printCalib;                                                        //not important, i made it just so i can easily cancel printing some stuff by changing the value to TRUE (1) or FALSE (0)
bool racing;                                                            //this is to test if racing mode is enabled
int ESC_Y1; int ESC_Y2; int ESC_Y3; int ESC_Y4; int ESC_Y5; int ESC_Y6; //Right stick: up/down values  to ESC (Forward/Back)
int ESC_X1; int ESC_X2; int ESC_X3; int ESC_X4; int ESC_X5; int ESC_X6; //Left Stick: left/right values to ESC(Left/Right Turn)
unsigned long timeLoopBegin = 0;
unsigned long timeLoopEnd = 0;
//This is a list of global variables we will need to use the function I made called "smoothing(axis#,index#)"
//It will read and average the first "smoothingValue" it reads
//NOTE: After much testing, i made the readings stable eough and didnt need this function as much (seems like i had a power issue with my arduino) The smoothing function was also causing delays in the LCD screen so we wont need to use the smoothing() function anymore
#define amountToAverage 1                                     //this is the amount we will read and keep averaging.
#define x amountToAverage
#define numOfSticks 10                                        //(leftx,lefty,rightx,righy) so 4 axises we need to measure, 1 motor speed potentiometer and got room to add 5 more pot if we needed more, obviously we can add much as we want tho, but though that 10 would be a safe #
const int smoothingValue[numOfSticks] = {x, x, x, x, x, x};   //this was we can use one function to average all axis.
int readings[numOfSticks][x] = {};                            //2 dimentional array:1st index is the axis#(leftx,lefty,righx,righy); 2nd index says that we want the readings to be as big as the #s we want to average
int readIndex[numOfSticks] = {0};                             //(leftx,lefty,rightx,right) will all be 0 (had to put 4 0s for 4 axis)
int total[numOfSticks] = {0};                                 //I didnt know how to set all the elements in an array to one value :/ is this how to do it?
int average[numOfSticks] = {0};
//These are global variables to store the neutral positions of all brushless motors in a function i made called "calib_neutral()" and which will help with neutral valiables below. which will calibrate the joystick to the ESC neutral positions, the length of it is 30, which is a lot more than we need lol. we only needed 7
int middle[30] = {};                                          //middle neutral position
int lowN [30] = {};                                           //lowest range
int hiN [30] = {};                                            //highest range
//This is for the lowest value of the 2nd ESC neutral range for "reverseESC()" and "motorSpeedCalib()"
int lowest[30] = {};                                          //found out that some ESCs have another neutral range, this is the highest value of the lowest neutral range (basically the ESCs we r using have neutrals from 0-15 (16 then being this variable), and a range near 90(which is sotred in the 3 variables above this). 
//These is global variables used for "setNeutral()" its the "stop the motor" position for specific ESCs
int neutral0; int neutral1; int neutral2; int neutral3; int neutral4; int neutral5; int neutral6;


void loop() {
  racing = false;                   //currently not in racing mode, this is only used to toggle some LCD printing stuff
  printCalib = 1;                   //This isnt important. This is just to toggle on or off some serial printing stuff. dont want it to print all the calib steps, so for test 1 will enable all printing, 0 will disable all printing
///////////////////////////////////////(Read All Switches: WHAT MODE IS IT IN?)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < sizeOfArray; i++) {
    buttonstateArray[i] = digitalRead(switchModeArray[i]);        //read all the switchbuttons
  }
  data.left_sw = buttonstateArray[0];                             //put them in the packet so we can send them out to the reciever
  data.right_sw = buttonstateArray[1];
  data.lifting_sw =  buttonstateArray[2];
  data.throwing_sw = buttonstateArray[3];
  data.climbing_sw = buttonstateArray[4];
  data.hitting_sw =  buttonstateArray[5];
  data.STOP_sw = buttonstateArray[6];
  data.levelUP_sw = buttonstateArray[7];
  data.levelDOWN_sw = buttonstateArray[8];
  Serial.print("Buttons:");
  Serial.print(data.lifting_sw); Serial.print(" ");
  Serial.print(data.throwing_sw); Serial.print(" ");
  Serial.print(data.climbing_sw); Serial.print(" ");
  //Serial.print(data.hitting_sw);Serial.print(" ");
  Serial.print(data.STOP_sw); Serial.print("   ");
  //Serial.print(data.levelUP_sw);Serial.print(" ");
  //Serial.print(data.levelDOWN_sw);Serial.print("       ");
//////////////////////////////////////(Joystick Calibration #1: Read+Smooth Values)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( 1 )//////////////////////////////////////////////
  int left_x = analogRead(leftStick_x);   int right_x = analogRead(rightStick_x);         //read the uncalibrated stick
  int left_y = analogRead(leftStick_y);   int right_y = analogRead(rightStick_y);
  int leftStick_sw = digitalRead(leftStick_sw); int rightStick_sw = digitalRead(rightStick_sw);
  left_x = smoothing(left_x, 0);                        //Joystick Calibration#1: Stabalize the initial readings
  //left_y = smoothing(left_y,1);                       //use the index: 0 for left_x...1 for left_y...2 for right_x..etc it doesnt really matter what number as long as each index# is different
  //right_x = smoothing(right_x,2);                     //not using left y and right x axis yet so dont need these lines yet
  right_y = smoothing(right_y, 3);
  if (printCalib == 1) {
    Serial.print("    C1 RY: ");     Serial.print(right_y);
    Serial.print("     ");
  }
///////////////////////////////////////////(TEST JOYSTICK)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  bool doTest = 0;                                                      //change to true if we are trying to calibrate the joystick! if its false, it will skip this section, if its true, it will do this black only
  if (doTest == true)
  {
    int testStick_LeftX  = isreverse(left_x, true);
    int testStick_LeftY  = isreverse(left_y, false);
    int testStick_RightX = isreverse(right_x, false);
    int testStick_right = isreverse(right_y, true);
    int speedPotTest = analogRead(motorSpeed_Pot);
    speedPotTest = smoothing(speedPotTest, 5);                            //smooth the speed potentiometer values
    Serial.print("           ");
    Serial.print("testLEFTx: ");       Serial.print(testStick_LeftX);
    Serial.print("   testLEFTy: ");     Serial.print(testStick_LeftY);
    Serial.print("      ");
    Serial.print("testRIGHTx: ");        Serial.print(testStick_RightX);
    Serial.print("   testRIGHTy:");     Serial.print(testStick_right);
    Serial.print("               ");
    Serial.print("{InitialSpeedPot: ");
    Serial.print(speedPotTest);
    Serial.print("}  {*TEST RUNNING*}");
  }
  else
  {
//////////////////////////////////////(Joystick Calibration #2: Turn to Servo)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( 2 )/////////////////////////////////////////////
    //Joystick Calibration#2: calibratejoystick(stick name, lowest value ,middle,highest value, reversed?):
    left_x = calibrateJoystick(left_x, 4, 521, 1018, true);                         //if the stick is reversed, correct it
    left_y = calibrateJoystick(left_y, 10, 502, 1020, false);                       //if the stick values oscillates, stabilize it
    right_x = calibrateJoystick(right_x, 5, 503, 1014, false);                      //finally, map to servo  //middle:489,497,498,509,
    right_y = calibrateJoystick(right_y, 10, 502, 1010, true);                      //Note: All the code  we need to change for calibration (like these 4 lines) are not indented so that we can notice them quicker
    if (printCalib == 1) {
      Serial.print("C2 LX: ");     Serial.print(left_x);
      Serial.print("  ");
      Serial.print("C2 RY: ");     Serial.print(right_y);
      Serial.print("     ");
    }
//////////////////////////////////////(Joystick Calibration #3: ESC NEUTRAL:)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( 3 )////////////////////////////////////////////
    //calib_neutral(index#to store neutral position of motor, stickAxis,low neutral of motor, high neutral of motor)
    int defaultStick = calib_neutral(0, right_y, 90, 90);                       //this is the Joystick without any ESC calibration
    int stickESC_Y1 = calib_neutral(1, right_y, 90, 94);                            //93,101; Joystick Calibration#3: correct the 0-middle-180 to the specific ESC neutral position (which will be the new middle position)
    int stickESC_Y2 = calib_neutral(2, right_y, 90, 90);
    int stickESC_Y3 = calib_neutral(3, right_y, 90, 90);
    int stickESC_Y4 = calib_neutral(4, right_y, 90, 90);
    int stickESC_Y5 = calib_neutral(5, right_y, 90, 90);
    int stickESC_Y6 = calib_neutral(6, right_y, 90, 90);
    int defaultStick_x = calib_neutral(0, left_x, 90, 90);                      //this is the Joystick without any ESC calibration
    int stickESC_X1 = calib_neutral(left_x, neutral1);
    int stickESC_X2 = calib_neutral(left_x, neutral2);
    int stickESC_X3 = calib_neutral(left_x, neutral3);
    int stickESC_X4 = calib_neutral(left_x, neutral4);
    int stickESC_X5 = calib_neutral(left_x, neutral5);
    int stickESC_X6 = calib_neutral(left_x, neutral6);
    if (printCalib == 1) {
      Serial.print("C3 LX1: ");  Serial.print(stickESC_X1);
      Serial.print("  ");
      Serial.print("C3 RY1: "); Serial.print(stickESC_Y1);
      Serial.print("     ");
    }
//////////////////////////////////////(GET NEUTRAL POSITION FOR EACH ESC)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( NEUTRAL )////////////////////////////////////////
    neutral0 = middle[0];
    neutral1 = middle[1];                                              //im just recalling the neutral positions i have set up using the previous function "calib_neutral"
    neutral2 = middle[2];                                              //will use these neutral positions to stop all motors when the STOP button is pressed
    neutral3 = middle[3];
    neutral4 = middle[4];
    neutral5 = middle[5];
    neutral6 = middle[6];
//////////////////////////////////////////(Calibrate MOTORSPEED:)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( MOTOR )//////////////////////////////////////////
    int speedPot = analogRead(motorSpeed_Pot);
    //speedPot = isreverse(speedPot,true);                                //uncomment if the speed pot is reversed

    speedPot = smoothing(speedPot, 5);                                    //smooth the speed potentiometer values
    if (printCalib == 1){
      Serial.print("InitialPot: ");
      Serial.print(speedPot);
      Serial.print("  ");
    }
    speedPot = map(speedPot, 10, 1010, 0, 100);                               //map the speed pot to 0 to 1023
    speedPot = constrain(speedPot, 0, 100);                               //constrain the values to 0 to 1023 (this is for more accuracy)
//////////////////////////////////////(Joystick Calibration #4: Speed Potententiometer Sets Limits)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( 4 )////////////////////////////////////////////
    //ESC1,2,3 (LEFT MOTORS) ESC4,5,6 (RIGHT MOTORS)
    //see the parameter description: motorSpeedCalib(index to store the lowest val of 2nd rage, stickESCAxis,lowest value of motor for second neutral range(added this), middle neutral from "calib_neutral(), speedPotentiometer)"
    int defaultStickSpeed = motorSpeedCalib(0, defaultStick, 0, neutral0, speedPot);    //Joystick Calibration#4: Calibrate the joystick valeus to the speed potentiometer, so that we can set how fast a motor can go at any given moment
    ESC_Y1 = motorSpeedCalib(1, stickESC_Y1, 16, neutral1, speedPot);
    ESC_Y2 = motorSpeedCalib(2, stickESC_Y2, 16, neutral2, speedPot);
    ESC_Y3 = motorSpeedCalib(3, stickESC_Y3, 16, neutral3, speedPot);
    ESC_Y4 = motorSpeedCalib(4, stickESC_Y4, 16, neutral4, speedPot);
    ESC_Y5 = motorSpeedCalib(5, stickESC_Y5, 16, neutral5, speedPot);
    ESC_Y6 = motorSpeedCalib(6, stickESC_Y6, 16, neutral6, speedPot);
    int defaultStickSpeed_x = motorSpeedCalib(0, defaultStick_x, neutral0, speedPot);   //retrieve the lowest val of the range from the index, and then do the same thing done above
    ESC_X1 = motorSpeedCalib(1, stickESC_X1, neutral1, speedPot);
    ESC_X2 = motorSpeedCalib(2, stickESC_X2, neutral2, speedPot);
    ESC_X3 = motorSpeedCalib(3, stickESC_X3, neutral3, speedPot);
    ESC_X4 = motorSpeedCalib(4, stickESC_X4, neutral4, speedPot);
    ESC_X5 = motorSpeedCalib(5, stickESC_X5, neutral5, speedPot);
    ESC_X6 = motorSpeedCalib(6, stickESC_X6, neutral6, speedPot);

/////////////////////////////////////////(If Statements: RACING/CLIMBING)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( RACING/CLIMBING /////////////////////////////////
    //LCD PRINTING, RESETS ALL VALUES to NEUTRAL when ALL stick at midde. IF RIGHT STICK MIDDLE, and the LEFT stick is to the left/right, all the right ESCs values are reversed (so the robot can turn). If RIGHT stick is up or down and LEFT stick is left or right, the OUTGOING singal will only be set to the up/down values (for now anyways, the more complicated thing is to set the left and right as into motion so we can drift while going forward or something). if the RIGHT stick is middle, and the LEFT stick is left or right, we can left/right turn
    if ((data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 0 && /*data.hitting_sw==0 &&*/ data.STOP_sw == 0) || (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 1 /*&& data.hitting_sw==0 */ && data.STOP_sw == 0)) //for testing reason i commented out the hitting switch. also, because climbing and racing uses the same movement, i set it up so that while in racing mode (all buttons at 0) the motors can go full 100%, in climbing mode (climbing switch pressed) the motors can be restricted
    {
      racing = true;
      if (data.climbing_sw == 0) {
        lcd.setCursor (3, 0);
        lcd.print(" Racing MODE ");
      }
      if (data.climbing_sw == 1) {
        lcd.setCursor (3, 0);
        lcd.print("  Climb MODE  ");
        //in the climbing mode statement, we will constrain the speed of whatever goes out from this block
      }
      /*-------------------------------------------------------------(RIGHT: up)-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

      if (defaultStick > 93)                                                                              //If RIGHT stick up, print FORWARD % + change OUTGOING
      {
        lcd.setCursor (16, 3);
        lcd.print("%   ");
        int forwardStick = map(defaultStickSpeed, 90, 180, 0, 100);
        lcd.setCursor (4, 3);
        lcd.print("FORWARD: ");
        lcd.setCursor (13, 3);
        lcd.print(forwardStick);
        if (forwardStick <= 9) {
          lcd.setCursor (14, 3);
          lcd.print("  ");
        }
        if (forwardStick >= 100) {
          lcd.setCursor (15, 3);
          lcd.print("0");
        }
        else {
          lcd.setCursor (15, 3);
          lcd.print(" ");
        }
        data.ESC0 = defaultStickSpeed;
        data.ESC_1 = ESC_Y1;
        data.ESC_2 = ESC_Y2;
        data.ESC_3 = ESC_Y3;
        data.ESC_4 = ESC_Y4;
        data.ESC_5 = ESC_Y5;
        data.ESC_6 = ESC_Y6;
      }                                                                                                    //***if the RIGHT stick up, insert the Y AXIS to OUTGOING
      /*-------------------------------------------------------------(RIGHT: down)--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
      if (defaultStick < 87)                                                                               //If RIGHT stick down, print BACK % + change OUTGOING
      {
        lcd.setCursor (14, 3);
        lcd.print("%   ");
        int backwardStick = map(defaultStickSpeed, 90, 0, 0, 100);
        lcd.setCursor (2, 3);
        lcd.print("   BACK:  ");
        lcd.setCursor (11, 3);
        lcd.print(backwardStick);
        if (backwardStick <= 9) {
          lcd.setCursor (12, 3);
          lcd.print(" ");
        }
        if (backwardStick >= 100) {
          lcd.setCursor (13, 3);
          lcd.print("0");
        }
        else {
          lcd.setCursor (13, 3);
          lcd.print(" ");
        }
        data.ESC0 = defaultStickSpeed;
        data.ESC_1 = ESC_Y1;
        data.ESC_2 = ESC_Y2;
        data.ESC_3 = ESC_Y3;
        data.ESC_4 = ESC_Y4;
        data.ESC_5 = ESC_Y5;
        data.ESC_6 = ESC_Y6;
      }                                                                                                  //***if RIGHT stick down, insert Y AXIS to OUTGOING
      /*-------------------------------------------------------------(LEFT: left)---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
      if (defaultStick_x < 87 && defaultStick >= 87 && defaultStick <= 93)                               //If LEFT stick left, & RIGHT stick is MIDDLE, print LEFT TURN % + change OUTGOING [stick goes to 0. left motors eed to go to 0, right motors need to go to 180] reverse right ESCs
      {
        lcd.setCursor (16, 3);
        lcd.print("%   ");
        int backwardStick_x = map(defaultStickSpeed_x, 90, 0, 0, 100);
        lcd.setCursor (4, 3);
        lcd.print("   LEFT:  ");
        lcd.setCursor (13, 3);
        lcd.print(backwardStick_x);
        if (backwardStick_x <= 9) {
          lcd.setCursor (14, 3);
          lcd.print(" ");
        }
        else if (backwardStick_x >= 100) {
          lcd.setCursor (15, 3);
          lcd.print("0");
        }
        else {
          lcd.setCursor (15, 3);
          lcd.print(" ");
        }
        data.ESC0 = defaultStickSpeed_x;
        data.ESC_1 = ESC_X1;
        data.ESC_2 = ESC_X2;
        data.ESC_3 = ESC_X3;
        data.ESC_4 = reverseESC(ESC_X4, 4);             //"reverseESC()" basically does this: map(ESC_X4, lowest[4],180, 180,lowest[4]); simple
        data.ESC_5 = reverseESC(ESC_X5, 5);
        data.ESC_6 = reverseESC(ESC_X6, 6);
      }                                                                                                 //***if right stick middle, insert X AXIS to OUTGOIN
      /*-------------------------------------------------------------(LEFT: right)--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
      if (defaultStick_x > 93 && defaultStick >= 87 && defaultStick <= 93)                              //If LEFT stick right, & RIGHT stick is MIDDLE, and print RIGHT TURN % + change OUTGOING  [stick goes 180. left motors: 180. right motors: 0] reverse right ESCs
      {
        lcd.setCursor (16, 3);
        lcd.print("%   ");
        int forwardStick_x = map(defaultStickSpeed_x, 90, 180, 0, 100);
        lcd.setCursor (4, 3);
        lcd.print("  RIGHT:  ");
        lcd.setCursor (13, 3);
        lcd.print(forwardStick_x);
        if (forwardStick_x <= 9) {
          lcd.setCursor (14, 3);
          lcd.print(" ");
        }
        else if (forwardStick_x >= 100) {
          lcd.setCursor (15, 3);
          lcd.print("0");
        }
        else {
          lcd.setCursor (15, 3);
          lcd.print(" ");
        }
        data.ESC0 = defaultStickSpeed_x;
        data.ESC_1 = ESC_X1;
        data.ESC_2 = ESC_X2;
        data.ESC_3 = ESC_X3;
        data.ESC_4 = reverseESC(ESC_X4, 4);
        data.ESC_5 = reverseESC(ESC_X5, 5);
        data.ESC_6 = reverseESC(ESC_X6, 6);
      }                                                                                                    //***if right stick middle, insert X AXIS to OUTGOING
      /*-------------------------------------------------------------(MIDDLE)--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
      //MIDDLE BOTH: reset data for whichever stick is middle
      if (defaultStick >= 87 && defaultStick <= 93) {                                                      //If RIGHT stick is MIDDLE, reset Y data to neutral
        reset_y();
      }
      if (defaultStick_x >= 87 && defaultStick_x <= 93) {                                                  //If LEFT stick is MIDDLE, reset X data to neutral
        reset_x();
      }
      if (defaultStick >= 87 && defaultStick <= 93 && defaultStick_x >= 87 && defaultStick_x <= 93) {      //If the LEFT/RIGHT stick is MIDDLE, print that its still
        lcd.setCursor (4, 3);
        lcd.print("    STILL       ");
        stop();
      }
    }                                                                                                     //***Reset all to neutral if stick middle
/////////////////////////////////////////(If Statements: CLIMING)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( CLIMBING )///////////////////////////////////////
    if (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 1 /*&& data.hitting_sw==0*/ && data.STOP_sw == 0)         //Since we need more control in the Climbing Mode, we can limit how fast the motors can go by changign the "percent" variable
    {
      racing == true;
      int MAX_percent = 70;                                             //set how fast the motors can go during climbing, the speed potentiometer will be the new MAX percentage
      int percent = map(speedPot,0,100,0,MAX_percent);
      data.ESC0 = motorSpeedCalib(0,percent, data.ESC0);
      data.ESC_1 = motorSpeedCalib(1,percent, data.ESC_1);
      data.ESC_2 = motorSpeedCalib(2,percent, data.ESC_2);
      data.ESC_3 = motorSpeedCalib(3,percent, data.ESC_3);
      data.ESC_4 = motorSpeedCalib(4,percent, data.ESC_4);
      data.ESC_5 = motorSpeedCalib(5,percent, data.ESC_5);
      data.ESC_6 = motorSpeedCalib(6,percent, data.ESC_6);
      printSpeedPot(percent); 
    }
/////////////////////////////////////////(If Statements: STOP)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( STOP )///////////////////////////////////////////
    else if (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 0 /*&& data.hitting_sw==0*/ && data.STOP_sw == 1)      //RESETS Y VALUES to NEUTRAL when stop is pressed
    {
      racing == true;
      reset_y();
      reset_x();
      stop();
      Serial.print("      STOP ACTIVE      ");
      lcd.setCursor (3, 0);
      lcd.print(" STOP MODE ");
      Serial.print("count: ");                                                               //somethings the LCD malfunctions and prints random symbols, so i made it so that if we pressed the STOp button 5 times, it will rest the lcd
      Serial.print(counter);
      Serial.print("   ");  
      counter++;
      if (counter >= 5) {
        lcd.clear();
        delay(20);
        Serial.print("   LCD CLEARED   ");
        counter = 0;
      }
    }
   
/////////////////////////////////////////(If Statements: LIFTING)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( LIFTING )////////////////////////////////////////
    //READS+ACTIVATES LEVEL UP/DOWN BUTTONS; SEND BUTTONS TO ROBOT; DISABLES STICKS
    else if (data.lifting_sw == 1 && data.throwing_sw == 0 && data.climbing_sw == 0 /*&& data.hitting_sw==0*/ && data.STOP_sw == 0)      //Not Racing/climbing mode so motors are disabled; Activte the level UP/DOWN buttons so we can move the scissor lift DC motor
    {
      reset_y();
      reset_x();
      stop();
      //Read the level buttons
      data.levelUP_sw =  digitalRead(levelUP_sw);
      data.levelDOWN_sw = digitalRead(levelDOWN_sw);
      //****map the servo to the DC motor****
      lcd.setCursor (0, 0);                              
      lcd.print("    Lifting MODE    ");
      lcd.setCursor (0, 1);                               //Print "Level Buttons Activated"
      lcd.print("Level Buttons ACTIVE"); 
      /*if (data.levelUP_sw == 1){                        //commenting this for now since i dont have the buttons connected
        lcd.setCursor (0, 2);                             //if we r lifting, print that we are
        lcd.print("      GOING UP      ");
      }
      if (data.levelDOWN_sw == 1){
        lcd.setCursor (0, 2);                         
        lcd.print("     GOING DOWN     ");
      }*/
    }
    
/////////////////////////////////////////(If Statements: THROWING)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( THROWING )///////////////////////////////////////
  
    else if (data.lifting_sw == 0 && data.throwing_sw == 1 && data.climbing_sw == 0 /*&& data.hitting_sw==0*/ && data.STOP_sw == 0)     //NEED MROE INFORMATION
    {
      reset_y();
      reset_x();
      stop();
      lcd.setCursor (0, 0);                             //Print "Throwing Mode in Display"
      lcd.print("   Throwing MODE    ");
      //****NEED MORE INFORMATION***
    }
   
/////////////////////////////////////////(If Statements: HITTING)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( HITTING )///////////////////////////////////////
    /*
        else if (data.lifting_sw==0 && data.throwing_sw==0 && data.climbing_sw==0 && data.hitting_sw==1 && data.STOP_sw==0)               //NEED MROE INFORMATION
        {
          reset_y();
          reset_x();
          stop();
          lcd.setCursor (0, 0);                           //Print "Hitting Mode in Display"
          lcd.print("    Hitting MODE    ");
              //****NEED MORE INFORMATION****
        }
    */
/////////////////////////////////////////(If Statements: Errors)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( ERRORS )////////////////////////////////////////
    if (racing == true) {
      lcd.setCursor (3, 2);
      lcd.print("              ");
    }
    else if (racing == false) {
      clearMotors_LCD();                             //not in racing mode so clear the ESC positions printed on the LCD
    }
    else {
      reset_x();
      reset_y();
      stop();
      /*lcd.setCursor (0, 0);
        lcd.print("    SWITCH ERROR!   ");                  //if 1+ switch on, tell me that it is
        lcd.setCursor (0, 1);
        lcd.print("                    ");*/
    }
    
/////////////////////////////////////////(END)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////( END )/////////////////////////////////////////
    radio.write( &data, sizeof(controllerData) );               //send all this data to the reciever where the reciever will then supply the motors with the code to go
    if (!radio.write( &data, sizeof(controllerData) ))         //if it fails to send, reset the data to all neutral pulses
    {
      Serial.print("failed!    ");
      reset_y();
      reset_x();
      stop();
      lcd.setCursor (0, 3);
      lcd.print("FAILx");
    }//end of if sending fails test statement 

    if (data.climbing_sw == 0){
      printSpeedPot(speedPot);     //too many conflicts in the 2nd row of the LCD, this statement makes things work out
    }     
    Serial.print("SpeedPot: ");
    Serial.print(speedPot);
    Serial.print("    ");   
    if (printCalib == 1){
      Serial.print("C4 LX1: ");    Serial.print(ESC_X1);          //will print the lastest ESC value when we r testing (can ignore this part)
      Serial.print("   ");
      Serial.print("C4 RY1: ");    Serial.print(ESC_Y1);
      Serial.print("         ");
    }
    Serial.print("*OUTGOING 1: ");         Serial.print(data.ESC_1);      //this prints EXACTLY whats going out to ESC 1 (front left motor)
    Serial.print("        ");    
    if (radio.write(&data, sizeof(controllerData)))          //if it successfully sends the data, let me know exactly whats going out to each motor
    {
      defaultStick_LCD();                       //print the default stick so we will know if the sticks r stable
      if (racing == 1) {                        //if its racing/climbing/stop MODE, print all the motors.
        leftMotors_LCD();
        rightMotors_LCD();
      }
    }//end of writing to reciever  
  }//end of else statement
  Serial.println();
}//end of loop





///////////////////////////////////////////////// MY FUNCTIONS ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*-------------------------------------------------------------------(1.) SMOOTHING()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//WE DONT NEED THIS FUNCTION AS MUCH NOW!!!
//I based this function from this page: https://www.arduino.cc/en/tutorial/smoothing 
int smoothing(int stick, int index){                                       
  total[index] = total[index] - readings[index][readIndex[index]];        //Subtract the last reading
  readings[index][readIndex[index]] = stick;                              //read from the sensor, 
  total[index] = total[index] + readings[index][readIndex[index]];        //add the reading to the total:
  readIndex[index] = readIndex[index] + 1;                  // go to the next position in the array:
  if (readIndex[index] >= smoothingValue[index]) {          // if we are reaching the end of the array...
    readIndex[index] = 0;                            // ...go to the the beginning:
  }
  average[index]= total[index] / smoothingValue[index];           // calculate the average:
  return(average[index]);
}
/*DESCRIPTION
Basically this function will take the first...say 20 numbers (or whatever number we defined) and average them out
I had to add an index to the 2 parameters so that each joystick can have their own "file" or something.
left joystick and its x axis will be 0, left joystick and its x axis will be 1, etc. 
x axis of the left joystick will only go to the 0 "folder" and the y axis of the left joystick will of go to the 1 "folder" etc.

replace "stick" with whatever joystick we are using. example "right joystick up/down" is how we r gana go forward/back, so
                                                              "smoothing(right_y, 3)"                                                            
the index can be anything, we just need all the index #s to be different so readings for different sticks will be in different locations*/ 


/*-------------------------------------------------------------------(2.) CALIBRATEJOYSTICK()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//Take the analog values, stabalize the values, unreverse values, and turn into  Servo positions 
int calibrateJoystick(int stick, int low, int middle, int high, bool reverse)
{
  if (reverse == true)
  {
    stick = map(stick, 0,1023, 1023, 0);             //Since my right joystick is reverse, i maped the values the right way
  } 
  stick = stabilizeJoystick(stick, low, middle, high);
  stick = map2Servo(stick);
  return(stick);  
}

/*DESCRIPTION
"calibrateJoystick()" just takes in a stick and remap the highest, lowest, and middle position of a joystick to desirable values
 *  if its reversed, it fixes it
 *  if its still unstable, it stabalizes it by remapping to 512 as middle (1023/2=512)
 *  and finally, it turns the 0-512-1023 value to servo positions (0-90-180) for our ESCs 
    (ESCs are devices that take DC power and converts it into AC current to drive the brushless motors. each of the 3 wires of the ESC gives off pulses of different lengths and intervals to the motor to keep it spinning) 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//Here are the other functions that are included in the "calibrateJoystick()" function:
int stabilizeJoystick( int stick,int lower,int middle,int upper)
{
  stick = constrain(stick, lower, upper);     
  if (stick < middle)       
    stick = map(stick,lower, middle, 0,512);                                                      
  else
    stick = map(stick, middle, upper, 512, 1023);
  return(stick);   
}
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
int map2Servo(int calibratedStick)
{
  if (calibratedStick < 90)       
    calibratedStick = map(calibratedStick,5, 512, 0,90);              //i set it to 5 and not 0 to ensure it will go to 0                                                
  else
    calibratedStick = map(calibratedStick,512, 1020, 90,180);         //i set it to 1020 and not 1023 to ensure it will go to 180     
  return(calibratedStick);
}
/*-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
int isreverse(int stick, bool reverse)
{
  if (reverse == true)
  {
    stick = map(stick, 1023, 0, 0,1023);             //Since my right joystick is reverse, i maped the values the right way
  }  
  return(stick);
}


/*-------------------------------------------------------------------(3.) CALIB_NEUTRAL()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
int calib_neutral(int index, int stick, int lowNeutral, int highNeutral)
{ 
  int middleNeutral = ((highNeutral-lowNeutral)/2)+lowNeutral;              //get the low and high neutral position of a specific ESC, and find the middle of the neutral positions
  middle[index] = middleNeutral;                                            //store that middle neutral position to whatever index i choose (this way, all each neutral position of whatever ESC we r currently using will stay in that place we setup using the index#)
  lowN[index] = lowNeutral;                                                 //store the low and high neutral positions, we will reuse these arrays to print the position of all motors on the LCD
  hiN[index] = highNeutral;
  if (stick > middleNeutral){       
    stick = map(stick, 90, 180, middleNeutral, 180 );    
    }                                                   
  if (stick < middleNeutral) 
    stick = map(stick, 0, 90, 0, middleNeutral);
  return(stick);     
}

int calib_neutral(int stick, int middleNeutral)                  //this is just a function i made to do the x axis, since we already found the middle neutral position, it wont make sense to re type the same numbers
{
  if (stick > middleNeutral){       
    stick = map(stick, 90, 180, middleNeutral, 180 );    
    }                                                   
  if (stick < middleNeutral) 
    stick = map(stick, 0, 90, 0, middleNeutral);
  return(stick);     
}
/*DESCRIPTION
"calibNeutral()" takes it 3 things:
1.) It takes a stick variable (lets say the y axis (up/down) of the right joystick) 
2.) The range of the neutral position of a specific ESC (the values where the motor is in between forward and reverse and doesnt turn)
3.) the  index number, basically the position where the MIDDLE neutral position will be stored (in the "middle[]" array)    
and does 2 things:
1.) it takes the middle position of the neutral range and stores that middle neutral position to the array "middle" that we defined before the "void loop()" function
2.) It then maps the joystick so that the middle neutral position becomes the new middle value and then returns it so that we can equal it to the stick of our choosing*/


/*-------------------------------------------------------------------(4.) MOTORSPEEDCALIB()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/*PARAMETER DEFINATION for the 2 functions below: 
 motorSpeedCalib([index to store the lowest position],[what ESC and axis?],[lowest 2nd neutral position that will be stored in the "lowest[]" array],[the middle neutral position of the ESC that we got from the "calib_neutral()" function],[the speed Pot value that will constrain the motor speed])*/                              
int motorSpeedCalib(int index, int stick, int lowestVal, int middle, int speedPot){
    lowest[index] = lowestVal;                                                      //here we will store the lowest positions into the array so we can use this arry to do the X positions (function below) and can also use this array when we need to reverse the ESCs in "reverseESC()" function
    int speedPotForward = map(speedPot, 0, 100, middle, 180);
    int speedPotBack = map(speedPot, 0, 100, middle, lowestVal);
    if (stick > middle){
      stick = map(stick, middle,180, middle,speedPotForward); 
    }
    if (stick < middle){
      stick = map(stick, 0, middle, speedPotBack, middle);                         //had to add the "lowestVal paramater in this function because during testing i noticed that in addition to the neutral position near 90, some motors also have a second neutral position near 0 (the 2 motors i tests have the 2nd neutral from 0 to 15)
    } 
    return(stick);
}
int motorSpeedCalib(int index, int stick, int middle, int speedPot){
    int lowestVal = lowest[index];
    int speedPotForward = map(speedPot, 0, 100, middle, 180);
    int speedPotBack = map(speedPot, 0, 100, middle, lowestVal);
    lowest[index] = lowestVal;
    if (stick > middle){
      stick = map(stick, middle,180, middle,speedPotForward); 
    }
    if (stick < middle){
      stick = map(stick, 0, middle, speedPotBack, middle);                        //had to add the "lowestVal paramater in this function because during testing i noticed that in addition to the neutral position near 90, some motors also have a second neutral position near 0 (the 2 motors i tests have the 2nd neutral from 0 to 15)
    } 
    return(stick);
}
/*DESCRIPTION for the 1stfucntion
This functions allows the joystick to be able to be constrained by the speed potentiometer. 
Basically, if we move the potentiometer slider to the right, all motors will be able to operate at 100% forward (Servo value 180) and backward (Servo value 0 for the 2nd function and whatever "lowestVal" is set to in the 1st function)
If we slide the potentiometer to the left, it will make the motors operate at 0% speed (basically it wont move). 
90 is usually the neutral position, but since each ESC has their own neutral position, turning the potentiometer to 0% will set each ESC to their specific neutral position that we defined by the "calib_neutral()" functon. 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PARAMETER DEFINATION for 3rd function: 
motorSpeedCalib([index to store the lowest position],[what percent can the motors travelat?] [what data.ESC to calibrate?])*/
int motorSpeedCalib(int index, float percentage, int stick){   
    int lowestVal = lowest[index];
    int MAXSpeed_FORWARD = ((180-middle[index]) * (percentage/100))+ middle[index];                   //basically tke the percentage value and change up the max and min we can go
    MAXSpeed_FORWARD = MAXSpeed_FORWARD ;
    int MAXSpeed_BACK = (middle[index] - ((middle[index] - lowestVal)*(percentage/100)));         
    if (stick > middle[index]){
      stick = map(stick, middle[index],180, middle[index],MAXSpeed_FORWARD); 
    }
    if (stick < middle[index]){
      stick = map(stick, lowestVal,middle[index], MAXSpeed_BACK,middle[index]);         
    }
    return(stick);
}
/*DESCRIPTION
This one was made for the Climbing Event, it basically takes in the LATEST data.ESC values and limits the power 
(the latest data.ESC values were created using the first 2 motorSpeedCalib() above and then stored in the data.ESC structre thing in the If Statement blocks*/


/*-------------------------------------------------------------------(5.) STOP()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
void stop(){                                                //feed the motors with the neutral pulses
    data.ESC0 = neutral0;
    data.ESC_1 = neutral1;           
    data.ESC_2 = neutral2;
    data.ESC_3 = neutral3;
    data.ESC_4 = neutral4;
    data.ESC_5 = neutral5;
    data.ESC_6 = neutral6;
}

int reverseESC(int stick, int index ){                        //just a quick and easy function to reverse the ESC positions. 
  stick = map(stick, lowest[index], 180,180,lowest[index]);
  return(stick); 
}


/*-------------------------------------------------------------------(5.) LCDPRINTING()---------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
void printSpeedPot(int speedPot){
  if (data.lifting_sw == 0)                       //If the lifting mode switch isnt pressed, printing the speed potentiometer percentage on the LCD is allowed
  {  
    lcd.setCursor (3, 1);                               
    lcd.print(" Speed: ");         
    lcd.setCursor (14, 1);                       
    lcd.print("%  ");
    lcd.setCursor (11, 1);   
    lcd.print(speedPot);
    if (speedPot <=9){                 
      lcd.setCursor (12, 1);                       
      lcd.print(" ");     
    }
    if (speedPot >= 100){
      lcd.setCursor (13, 1);                       
      lcd.print("0");     
    }
    else{
      lcd.setCursor (13, 1);                       
      lcd.print(" ");  
    }
  }  
}/*end of printing the Speed Pot percentage
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void defaultStick_LCD()                           //print the default stick values ("defaultStickSpeed" and "defaultStickSpeed_x" that is going to the reciever 'ESC0') this is just a test to see that the sticks are stable
{
  lcd.setCursor(0, 3);
  lcd.print(data.ESC0);  
  lcd.setCursor (3, 3);
  lcd.print(" ");  
  if (data.ESC0 >= 100){
    lcd.setCursor(2, 3);
    lcd.print("0");  
  }
  else if (data.ESC0 <= 9){
    lcd.setCursor(1, 3);
    lcd.print("  ");  
  }
  else{ 
    lcd.setCursor(2, 3);
    lcd.print(" ");  
  }
}/*end of function
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void clearMotors_LCD(){                                             //this function just cleans the neutral postions if we r not racing
  lcd.setCursor (0, 0);       //left1                        
  lcd.print("   ");  
  lcd.setCursor (17, 0);      //right1                      
  lcd.print("   ");  
  if (data.lifting_sw == 0){                                        //the lifting switch take sup the second line, so the positions are only cleared if the lifting switch isnt pressed
  lcd.setCursor (0, 1);       //left2                         
  lcd.print("   ");  
  lcd.setCursor (17, 1);      //right2                      
  lcd.print("   ");  
  }
  lcd.setCursor (0, 2);       //left3                      
  lcd.print("   ");  
  lcd.setCursor (17, 2);      //right3                      
  lcd.print("   ");  
}/*end of function
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void leftMotors_LCD(){              
 /*-----------------------------------------------------------------------left 1*/
  lcd.setCursor(0, 0);              
  lcd.print(data.ESC_1);  
  lcd.setCursor (3, 0);
  lcd.print(" ");
  if ((lowN[1] <= data.ESC_1) && (data.ESC_1 <= hiN[1])){
   lcd.setCursor(0, 0);
   lcd.print("NEU");  
  }
  else if (data.ESC_1 >= 100){
    lcd.setCursor(2, 0);
    lcd.print("0");  
  }
  else if (data.ESC_1 <= 9){
    lcd.setCursor(1, 0);
    lcd.print("  ");  
  } 
  else if ((9 < data.ESC_1) && (data.ESC_1 < 100)){
    lcd.setCursor(2, 0);
    lcd.print(" ");  
  } 
 /*-----------------------------------------------------------------------left 2*/
  lcd.setCursor(0, 1);              
  lcd.print(data.ESC_2);  
  lcd.setCursor (3, 1);
  lcd.print(" ");
  if ((lowN[2] <= data.ESC_2) && (data.ESC_2 <= hiN[2])){
   lcd.setCursor(0, 1);
   lcd.print("NEU");  
  }
  else if (data.ESC_2 >= 100){
    lcd.setCursor(2, 1);
    lcd.print("0");  
  }
  else if (data.ESC_2 <= 9){
    lcd.setCursor(1, 1);
    lcd.print("  ");  
  } 
  else if (9 < data.ESC_2 < 100){
    lcd.setCursor(2, 1);
    lcd.print(" ");  
  } 
 /*-----------------------------------------------------------------------left 3*/
  lcd.setCursor(0, 2);              
  lcd.print(data.ESC_3);  
  lcd.setCursor (3, 2);
  lcd.print(" ");
  if ((lowN[3] <= data.ESC_3) && (data.ESC_3 <= hiN[3])){
   lcd.setCursor(0, 2);
   lcd.print("NEU");  
  }
  else if (data.ESC_3 >= 100){
    lcd.setCursor(2, 2);
    lcd.print("0");  
  }
  else if (data.ESC_3 <= 9){
    lcd.setCursor(1, 2);
    lcd.print("  ");  
  } 
  else if (9 < data.ESC_3 < 100){
    lcd.setCursor(2, 2);
    lcd.print(" ");  
  } 
}//end of function

void rightMotors_LCD(){              
 /*-----------------------------------------------------------------------right 1*/
  lcd.setCursor(17, 0);              
  lcd.print(data.ESC_4);  
  lcd.setCursor (16, 0);
  lcd.print(" ");
  if ((lowN[4] <= data.ESC_4) && (data.ESC_4 <= hiN[4])){
   lcd.setCursor(17, 0);
   lcd.print("NEU");  
  }
  else if (data.ESC_4 >= 100){
    lcd.setCursor(19, 0);
    lcd.print("0");  
  }
  else if (data.ESC_4 <= 9){
    lcd.setCursor(18, 0);
    lcd.print("  ");  
  } 
  else if ((9 < data.ESC_4) && (data.ESC_4 < 100)){
    lcd.setCursor(19, 0);
    lcd.print(" ");  
  } 
 /*-----------------------------------------------------------------------right 2*/
  lcd.setCursor(17, 1);              
  lcd.print(data.ESC_5);  
  lcd.setCursor (16, 1);
  lcd.print(" ");
  if ((lowN[5] <= data.ESC_5) && (data.ESC_5 <= hiN[5])){
   lcd.setCursor(17, 1);
   lcd.print("NEU");  
  }
  else if (data.ESC_5 >= 100){
    lcd.setCursor(19, 1);
    lcd.print("0");  
  }
  else if (data.ESC_5 <= 9){
    lcd.setCursor(18, 1);
    lcd.print("  ");  
  } 
  else if ((9 < data.ESC_5) && (data.ESC_5 < 100)){
    lcd.setCursor(19, 1);
    lcd.print(" ");  
  } 
 /*-----------------------------------------------------------------------right 3*/
  lcd.setCursor(17, 2);              
  lcd.print(data.ESC_6);  
  lcd.setCursor (16, 2);
  lcd.print(" ");
  if ((lowN[6] <= data.ESC_6) && (data.ESC_6 <= hiN[6])){
   lcd.setCursor(17, 2);
   lcd.print("NEU");  
  }
  else if (data.ESC_6 >= 100){
    lcd.setCursor(19, 2);
    lcd.print("0");  
  }
  else if (data.ESC_6 <= 9){
    lcd.setCursor(18, 2);
    lcd.print("  ");  
  } 
  else if ((9 < data.ESC_6) && (data.ESC_6 < 100)){
    lcd.setCursor(19, 2);
    lcd.print(" ");  
  } 
}//end of function





  









                                                            
        



















