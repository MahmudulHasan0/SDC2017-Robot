#include <Wire.h>
#include <LiquidCrystal_I2C.h>              //LCD library: http://www.sunfounder.com/wiki/index.php?title=File:LiquidCrystal_I2C.zip
LiquidCrystal_I2C lcd(0x27, 20, 4);         //setting display to 0x27 address; 20 columns, 4 rows;  UNO:SDA(A4)SCL(A5); MEGA:SDA(pin20)SCL(pin21)
#include <SPI.h>                            //this library let microcontrollers communicate with each other quickly over short distances(MISO-send data to master from slave)(MOSI-send data from master to peripherals)(SCK-serial clock,clock pulses which synchronize data transmission generated by the master) 
#include <RF24.h>                           //NRF24 Library: https://github.com/TMRh20/RF24
#include <nRF24L01.h>                       //NRRF24 pin layout: UNO:  MOSI(pin11)MISO(pin12)SCK(pin13)(CE,CSN any pin; defined below)    
#include <printf.h>                         //                   MEGA: MOSI(pin51)MISO(pin50)SCK(pin52)(CE,CSN any pin; defined below)
#include <RF24_config.h>
#define CE_PIN   9//8
#define CSN_PIN  8//53
RF24 radio(CE_PIN, CSN_PIN);                
const uint64_t pipe = 0xE8E8F0F0E1LL;     

#define leftStick_x     A0                    
#define leftStick_y     A1
#define rightStick_x    A3
#define rightStick_y    A2
#define motorSpeed_Pot  A4
#define left_sw      22                          
#define right_sw     23
#define lifting_sw   4                   
#define throwing_sw  5                     
#define climbing_sw  6                   
#define hitting_sw   7                    
#define STOP_sw      39                    
#define levelUP_sw   15                     
#define levelDOWN_sw 16
const int sizeOfArray = 9;
int switchModeArray[] = {left_sw, right_sw, lifting_sw, throwing_sw, climbing_sw, hitting_sw, STOP_sw, levelUP_sw, levelDOWN_sw};
int buttonstateArray[sizeOfArray] = {};
int counter = 0;                           

//Global varibles for functions inside loop
bool printCalib; bool racing;                                                            
int ESC_Y1; int ESC_Y2; int ESC_Y3; int ESC_Y4; int ESC_Y5; int ESC_Y6; 
int ESC_X1; int ESC_X2; int ESC_X3; int ESC_X4; int ESC_X5; int ESC_X6; 
int ESC0; int ESC_1; int ESC_2; int ESC_3; int ESC_4; int ESC_5; int ESC_6;
unsigned long timeLoopBegin = 0; 
unsigned long timeLoopEnd = 0;
//store neutral positions of all motors ["calib_neutral()"]
int middle[30] = {};                                                //middle neutral position
int lowN [30] = {};                                                 //lowest range
int hiN [30] = {};                                                  //highest range
int lowest[30] = {};                                                //Lowest value of 2nd ESC neutral range ["reverseESC()" "motorSpeedCalib()"]
int right_x; int right_y; int left_x; int left_y; int defaultStick; int defaultStick_x; int defaultStickSpeed; int defaultStickSpeed_x; int speedPot; int testStick_LeftX; int testStick_LeftY; int testStick_RightX; int testStick_RightY; int speedPotTest;     //stuff im gana call in other functions

struct controllerData {                                                 
  int ESC0; int ESC_1; int ESC_2; int ESC_3; int ESC_4; int ESC_5; int ESC_6;    
  int motorSpeed_Pot;
  bool levelUP_sw;
  bool levelDOWN_sw;
  bool left_sw;
  bool right_sw;
  bool lifting_sw;
  bool throwing_sw;
  bool climbing_sw;
  bool hitting_sw;
  bool STOP_sw;
}; controllerData data;                               

void setup() {
  Serial.begin(250000);
  Serial.println("Starting");
  radio.begin();                                      
  radio.setPALevel(RF24_PA_MIN);                      
  radio.setDataRate(RF24_250KBPS);                    
  radio.setRetries(15, 15);                           
  radio.openWritingPipe(pipe);                        
  lcd.init();                                         
  lcd.backlight();                                    
  lcd.clear();                                        
  for (int i = 0; i < sizeOfArray; i++) {
    pinMode(switchModeArray[i], INPUT);              
    pinMode(switchModeArray[i], INPUT_PULLUP);        
  }
}//END OF SETUP
 
void loop() {
  racing = false;                                                    //currently not in racing mode, this is only used to toggle some LCD printing stuff
  readALLSwitches();
  print_ALLSwitches_onSerialMonitor();
  readRawJoystickValues();
  ///////////////////////////////////////////(TEST THE JOYSTICK)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  bool doTest = 0;                                                   //change to true if we are trying to calibrate the joystick! if its false, it will skip this section, if its true, it will do this black only
  if (doTest == true){
    testStick_LeftX  = isreverse(left_x, true);
    testStick_LeftY  = isreverse(left_y, false);
    testStick_RightX = isreverse(right_x, false);
    testStick_RightY = isreverse(right_y, true);
    speedPotTest = analogRead(motorSpeed_Pot);
    print_TestingStuff_onSerialMonitor();
  }
  ///////////////////////////////////////////(Test Ended)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  else
  {
    read_and_calibrate_speedPot();                                 ////(Calibrate sspeed potentiometer to limit speed of motors [TAB-05])///////////////   
    turn_sticks_to_servo();                                        ////(Joystick Calibration #01: Turn to Servo)//// 0-90-180
    calibrate_sticks_to_ESCs();                                    ////(Joystick Calibration #02: ESC NEUTRAL)/////  0-(ESC Low Netural<->ESC High Neutral)-180                    
    limitESCs_to_SpeedPot();                                       ////(Joystick Calibration #03)/////////////////   (ESC lowest position allowed by SpeedPot)-(ESC Low Netural<->ESC High Neutral)-(ESC highest position allowed by SpeedPot)    
                                                                       //Lets Speed Potententiometer Sets Limits)                                                               
////////////////////////////////////////////////////(If Statements: RACING/CLIMBING)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //for testing reason i commented out the hitting switch. also, because climbing and racing uses the same movement, i set it up so that while in racing mode (all buttons at 0) the motors can go full 100%, in climbing mode (climbing switch pressed) the motors can be restricted
    if ((data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 0 && data.hitting_sw==0 && data.STOP_sw == 0) || (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 1 && data.hitting_sw==0  && data.STOP_sw == 0))    
     {
      racing = true;
      print_RacingOrClimbingModes_onLCD();
/*------------------------------------------------------------------------(RIGHT: up)-------------------------------------------------------------------------------------------------------*/
      if (defaultStick > 93){                                                                                //If RIGHT stick up, print FORWARD % + change OUTGOING
        print_ForwardPercentage_onLCD();
        store_Yvalues_to_ESC();
      }                                                                                                     //if the RIGHT stick up, insert the Y AXIS to OUTGOING
/*------------------------------------------------------------------------(RIGHT: down)----------------------------------------------------------------------------------------------------*/                                                                                                              
      if (defaultStick < 87){                                                                               //If RIGHT stick down, print BACK % + change OUTGOING
        print_BackPercentage_onLCD();
        store_Yvalues_to_ESC();
      }                                                                                                     //if RIGHT stick down, insert Y AXIS to OUTGOING
/*------------------------------------------------------------------------(LEFT: left)-----------------------------------------------------------------------------------------------------*/
      if (defaultStick_x < 87 && defaultStick >= 87 && defaultStick <= 93){                                 //If LEFT stick left, & RIGHT stick is MIDDLE, print LEFT TURN % + change OUTGOING [stick goes to 0. left motors eed to go to 0, right motors need to go to 180] reverse right ESCs  
        print_LeftPercentage_onLCD();
        store_XTURNvalues_to_ESC();
      }                                                                                                 
/*------------------------------------------------------------------------(LEFT: right)----------------------------------------------------------------------------------------------------*/
      if (defaultStick_x > 93 && defaultStick >= 87 && defaultStick <= 93){                              //If LEFT stick right, & RIGHT stick is MIDDLE, and print RIGHT TURN % + change OUTGOING  [stick goes 180. left motors: 180. right motors: 0] reverse right ESCs 
        print_RightPercentage_onLCD();
        store_XTURNvalues_to_ESC();
      }                                                                                                   
/*--------------------------------------------------------------------------(MIDDLE)-------------------------------------------------------------------------------------------------------*/
      resetALLMotors();                                                                                               
    }                                                                                                     
  ///////////////////////////////////////////////////////////////////(If Statements: CLIMING)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 1 && data.hitting_sw==0 && data.STOP_sw == 0)         //Since we need more control in the Climbing Mode, we can limit how fast the motors can go by changign the "percent" variable
    {
      racing == true;
      int MAX_percent = 70;                                             //set how fast the motors can go during climbing, the speed potentiometer will be the new MAX percentage
      int percent = map(speedPot,0,100,0,MAX_percent);
      limitESCs_to_Percent(percent);
      print_SpeedPot_onLCD(percent); 
    }
////////////////////////////////////////////////////////////////////(If Statements: STOP)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 0 && data.hitting_sw==0 && data.STOP_sw == 1)      //RESETS Y VALUES to NEUTRAL when stop is pressed
    {
      racing == true;
      stop();
      print_STOPmode_andRefreshLCD();
    }
///////////////////////////////////////////////////////////////////(If Statements: LIFTING)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //READS+ACTIVATES LEVEL UP/DOWN BUTTONS; SEND BUTTONS TO ROBOT; DISABLES STICKS
    else if (data.lifting_sw == 1 && data.throwing_sw == 0 && data.climbing_sw == 0 && data.hitting_sw==0 && data.STOP_sw == 0)      //Not Racing/climbing mode so motors are disabled; Activte the level UP/DOWN buttons so we can move the scissor lift DC motor
    {
      stop();
      data.levelUP_sw =  digitalRead(levelUP_sw);                      //Read the level buttons
      data.levelDOWN_sw = digitalRead(levelDOWN_sw);
      print_LiftingMode_onLCD();                                       //****map the servo to the DC motor****
      /*if (data.levelUP_sw == 1){                                     //commenting this for now since i dont have the buttons connected
        lcd.setCursor (0, 2);                                          //if we r lifting, print that we are
        lcd.print("      GOING UP      ");
      }
      if (data.levelDOWN_sw == 1){
        lcd.setCursor (0, 2);                         
        lcd.print("     GOING DOWN     ");
      }*/
    }
/////////////////////////////////////////////////////////////////(If Statements: THROWING)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   
    else if (data.lifting_sw == 0 && data.throwing_sw == 1 && data.climbing_sw == 0 && data.hitting_sw==0 && data.STOP_sw == 0)     //NEED MROE INFORMATION
    {
      stop();
      print_ThrowingMode_onLCD();
      //****NEED MORE INFORMATION***
    }
/////////////////////////////////////////////////////////////////(If Statements: HITTING)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (data.lifting_sw==0 && data.throwing_sw==0 && data.climbing_sw==0 && data.hitting_sw==1 && data.STOP_sw==0)               //NEED MROE INFORMATION
    {
      stop();
      print_HittingMode_onLCD();
      //****NEED MORE INFORMATION****
    }
/////////////////////////////////////////////////////////////////(#04 REVERSE POLARITY?)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    data.ESC0 = ESC0;                                                 //use reverseESC to change the polarity, true if it need to be reverse, false otherwise
    data.ESC_1 = reverseESC(1,ESC_1, false);
    data.ESC_2 = reverseESC(2,ESC_2, true);                           //the left 2 motor need to be reversed
    data.ESC_3 = reverseESC(3,ESC_3, false);
    data.ESC_4 = reverseESC(4,ESC_4, false);
    data.ESC_5 = reverseESC(5,ESC_5, true);                           //the right 2 motor need to be reversed
    data.ESC_6 = reverseESC(6,ESC_6, false);
////////////////////////////////////////////////////////////////(If Statements: Errors)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (racing == true) {
      lcd.setCursor (3, 2);
      lcd.print("              ");
    }
    else if (racing == false) {
      clearMotors_LCD();                                             //not in racing mode so clear the ESC positions printed on the LCD
    }
    else {
      stop();
    }
///////////////////////////////////////////////////////////////////////(END)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    radio.write( &data, sizeof(controllerData) );                  //send all this data to the reciever where the reciever will then supply the motors with the code to go
    if (!radio.write( &data, sizeof(controllerData) ))             //if it fails to send, reset the data to all neutral pulses
    {
      Serial.print("failed!    ");
      stop();
      lcd.setCursor (0, 3);
      lcd.print("FAILx");
    }//end of "if sending fails" test statement 

    if (data.climbing_sw == 0){
      print_SpeedPot_onLCD(speedPot);                              //too many conflicts in the 2nd row of the LCD, this statement makes things work out
    }     
    Serial.print("SpeedPot: ");
    Serial.print(speedPot);
    Serial.print("    ");   
    if (printCalib == 1){
      Serial.print("C4 LX1: ");    Serial.print(ESC_X1);          //will print the lastest ESC value when we r testing (can ignore this part)
      Serial.print("   ");
      Serial.print("C4 RY1: ");    Serial.print(ESC_Y1);
      Serial.print("         ");
    }
    if (radio.write(&data, sizeof(controllerData)))              //if it successfully sends the data, let me know exactly whats going out to each motor
    { 
      print_defaultStick_onLCD();                                //print the default stick so we will know if the sticks r stable
      if (racing == 1) {                                         //if its racing/climbing/stop MODE, print all the motors.
        outgoing_leftMotors_LCD();
        outgoing_rightMotors_LCD();
      }
    }//end of writing to reciever 
    print_ALL_OUTGOINGS_onSerialMonitor();                       //prints exactly whats going out to each ESC
    printCalib = 0;                                                                       
  }//end of else statement    
  Serial.println();
}    



























































