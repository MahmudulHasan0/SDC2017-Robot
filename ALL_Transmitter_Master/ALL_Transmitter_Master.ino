#include <Wire.h>
#include <LiquidCrystal_I2C.h>              //LCD library: http://www.sunfounder.com/wiki/index.php?title=File:LiquidCrystal_I2C.zip
LiquidCrystal_I2C lcd(0x27, 20, 4);         //setting display to 0x27 address; 20 columns, 4 rows;  UNO:SDA(A4)SCL(A5); MEGA:SDA(pin20)SCL(pin21)

#include <SPI.h>                            //this library let microcontrollers communicate with each other quickly over short distances(MISO-send data to master from slave)(MOSI-send data from master to peripherals)(SCK-serial clock,clock pulses which synchronize data transmission generated by the master) 
#include <RF24.h>                           //NRF24 Library: https://github.com/TMRh20/RF24
#include <nRF24L01.h>                       //NRRF24 pin layout: UNO:  MOSI(pin11)MISO(pin12)SCK(pin13)(CE,CSN any pin; defined below)    
#include <printf.h>                         //                   MEGA: MOSI(pin51)MISO(pin50)SCK(pin52)(CE,CSN any pin; defined below)

#include <RF24_config.h>
#define CE_PIN   9//8
#define CSN_PIN  8//53
RF24 radio(CE_PIN, CSN_PIN);                
const uint64_t pipe = 0xE8E8F0F0E1LL;     


#define leftStick_x     A0                    
#define leftStick_y     A1
#define rightStick_x    A3
#define rightStick_y    A2
#define motorSpeed_Pot  A4
int left_sw  = 22;                          
int right_sw = 23;
int lifting_sw   = 4;                   
int throwing_sw  = 5;                      
int climbing_sw  = 6;                    
int hitting_sw   = 7;                     
int STOP_sw      = 39;                    
int levelUP_sw   = 15;                      
int levelDOWN_sw = 16;
const int sizeOfArray = 9;
int switchModeArray[] = {left_sw, right_sw, lifting_sw, throwing_sw, climbing_sw, hitting_sw, STOP_sw, levelUP_sw, levelDOWN_sw};
int *buttonstateArray = new int [sizeOfArray];
int counter = 0;                           

//Global varibles for functions inside loop
bool printCalib; bool racing;                                                         
int *ESC = new int[7];  
int *ESC_X = new int[7];  
int *ESC_Y = new int[7];  
unsigned long timeLoopBegin = 0; 
unsigned long timeLoopEnd = 0;
//store neutral positions of all motors ["calib_neutral()"]
const int size = 7;                 //6 motors that starts from index 1
int *middle = new int[size];        //middle neutral position
int *lowN = new int[size];          //lowest range
int *hiN = new int[size];           //highest range
int *lowest = new int[size];        //Lowest value of 2nd ESC neutral range ["reverseESC()" "motorSpeedCalib()"]
int right_x; int right_y; int left_x; int left_y; int defaultStick_y; int defaultStick_x; int defaultStickSpeed_y; int defaultStickSpeed_x; int speedPot; int testStick_LeftX; int testStick_LeftY; int testStick_RightX; int testStick_RightY; int speedPotTest;     //stuff im gana call in other functions

struct controllerData {    
  int *ESC = new int[7];                                               
  int motorSpeed_Pot;
  bool levelUP_sw;
  bool levelDOWN_sw;
  bool left_sw;
  bool right_sw;
  bool lifting_sw;
  bool throwing_sw;
  bool climbing_sw;
  bool hitting_sw;
  bool STOP_sw;
}; 
controllerData data;   //making the object                            

void setup() {
  Serial.begin(250000);
  Serial.println("Starting");
  radio.begin();                                      
  radio.setPALevel(RF24_PA_MIN);                      
  radio.setDataRate(RF24_250KBPS);                    
  radio.setRetries(15, 15);                           
  radio.openWritingPipe(pipe);                        
  lcd.init();                                         
  lcd.backlight();                                    
  lcd.clear();                                        
  for (int i = 0; i < sizeOfArray; ++i)
    //pinMode(switchModeArray[i], INPUT); 
    pinMode(switchModeArray[i], INPUT_PULLUP);        
}
 
void loop() {
  racing = false;                                                    //currently not in racing mode, this is only used to toggle some LCD printing stuff
  readALLSwitches();
  print_ALLSwitches_onSerialMonitor();
  readRawJoystickValues();
  ///////////////////////////////////////////(TEST THE JOYSTICK FOR QUICK CALIBRATION)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  bool doTest = 0;                                                   //change to true if we are trying to calibrate the joystick! if its false, it will skip this section, if its true, it will do this black only
  if (doTest == true){
    testStick_LeftX  = isreverse(left_x, true);
    testStick_LeftY  = isreverse(left_y, false);
    testStick_RightX = isreverse(right_x, false);
    testStick_RightY = isreverse(right_y, true);
    speedPotTest = analogRead(motorSpeed_Pot);
    print_TestingStuff_onSerialMonitor();
  }
  ///////////////////////////////////////////(Test Ended)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  else
  {
    read_and_calibrate_speedPot();  //(Calibrate speed potentiometer to limit speed of motors [TAB-05])///////////////   
    turn_sticks_to_servo();         //(Joystick Calibration #01: Turn to Servo) 0-90-180
    calibrate_sticks_to_ESCs();     //(Joystick Calibration #02: ESC NEUTRAL)   0-(ESC Low Netural<->ESC High Neutral)-180                    
    limitESCs_to_SpeedPot();        //(Joystick Calibration #03)                (ESC lowest position allowed by SpeedPot)-(ESC Low Netural<->ESC High Neutral)-(ESC highest position allowed by SpeedPot)   
     
    ///////////////////////////////////////////////////////////(RACING/CLIMBING)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //for testing reason i commented out the hitting switch. also, because climbing and racing uses the same movement, i set it up so that while in racing mode (all buttons at 0) the motors can go full 100%, in climbing mode (climbing switch pressed) the motors can be restricted
    if ((data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 0 && data.hitting_sw==0 && data.STOP_sw == 0) || (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 1 && data.hitting_sw==0  && data.STOP_sw == 0))    
     {
      racing = true;
      print_RacingOrClimbingModes_onLCD();
      /*------------------------------------------------------------------------(RIGHT: up)-------------------------------------------------------------------------------------------------------*/
      if (defaultStick_y > 93){                                                                                //If RIGHT stick up, print FORWARD % + change OUTGOING
        print_ForwardPercentage_onLCD();
        store_Yvalues_to_ESC();
      }                                                                                                     //if the RIGHT stick up, insert the Y AXIS to OUTGOING
      /*------------------------------------------------------------------------(RIGHT: down)----------------------------------------------------------------------------------------------------*/                                                                                                              
      if (defaultStick_y < 87){                                                                               //If RIGHT stick down, print BACK % + change OUTGOING
        print_BackPercentage_onLCD();
        store_Yvalues_to_ESC();
      }                                                                                                     //if RIGHT stick down, insert Y AXIS to OUTGOING
      /*------------------------------------------------------------------------(LEFT: left)-----------------------------------------------------------------------------------------------------*/
      if (defaultStick_x < 87 && defaultStick_y >= 87 && defaultStick_y <= 93){                                 //If LEFT stick left, & RIGHT stick is MIDDLE, print LEFT TURN % + change OUTGOING [stick goes to 0. left motors eed to go to 0, right motors need to go to 180] reverse right ESCs  
        print_LeftPercentage_onLCD();
        store_XTURNvalues_to_ESC();
      }                                                                                                 
      /*------------------------------------------------------------------------(LEFT: right)----------------------------------------------------------------------------------------------------*/
      if (defaultStick_x > 93 && defaultStick_y >= 87 && defaultStick_y <= 93){                              //If LEFT stick right, & RIGHT stick is MIDDLE, and print RIGHT TURN % + change OUTGOING  [stick goes 180. left motors: 180. right motors: 0] reverse right ESCs 
        print_RightPercentage_onLCD();
        store_XTURNvalues_to_ESC();
      }                                                                                                   
      /*--------------------------------------------------------------------------(MIDDLE)-------------------------------------------------------------------------------------------------------*/
      resetALLMotors();                                                                                               
    } 
                                                                                                        
    ///////////////////////////////////////////////////////////////////(CLIMING)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 1 && data.hitting_sw==0 && data.STOP_sw == 0)         //Since we need more control in the Climbing Mode, we can limit how fast the motors can go by changign the "percent" variable
    {
      racing == true;
      int MAX_percent = 70;                                             //set how fast the motors can go during climbing, the speed potentiometer will be the new MAX percentage
      int percent = map(speedPot,0,100,0,MAX_percent);
      limitESCs_to_Percent(percent);
      print_SpeedPot_onLCD(percent); 
    }
    
    ////////////////////////////////////////////////////////////////////(EMERGENCY STOP)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (data.lifting_sw == 0 && data.throwing_sw == 0 && data.climbing_sw == 0 && data.hitting_sw==0 && data.STOP_sw == 1)      //RESETS Y VALUES to NEUTRAL when stop is pressed
    {
      racing == true;
      stop();
      print_STOPmode_andRefreshLCD();
    }
    
    ///////////////////////////////////////////////////////////////////(LIFTING)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //READS+ACTIVATES LEVEL UP/DOWN BUTTONS; SEND BUTTONS TO ROBOT; DISABLES STICKS
    else if (data.lifting_sw == 1 && data.throwing_sw == 0 && data.climbing_sw == 0 && data.hitting_sw==0 && data.STOP_sw == 0)      //Not Racing/climbing mode so motors are disabled; Activte the level UP/DOWN buttons so we can move the scissor lift DC motor
    {
      stop();
      data.levelUP_sw =  digitalRead(levelUP_sw);                      //Read the level buttons
      data.levelDOWN_sw = digitalRead(levelDOWN_sw);
      print_LiftingMode_onLCD();                                       //****map the servo to the DC motor****
    }
    
    /////////////////////////////////////////////////////////////////(If Statements: THROWING)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   
    else if (data.lifting_sw == 0 && data.throwing_sw == 1 && data.climbing_sw == 0 && data.hitting_sw==0 && data.STOP_sw == 0)     //NEED MROE INFORMATION
    {
      stop();
      print_ThrowingMode_onLCD();
    }
    
    /////////////////////////////////////////////////////////////////(If Statements: HITTING)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (data.lifting_sw==0 && data.throwing_sw==0 && data.climbing_sw==0 && data.hitting_sw==1 && data.STOP_sw==0)               //NEED MROE INFORMATION
    {
      stop();
      print_HittingMode_onLCD();
    }
    
    /////////////////////////////////////////////////////////////////(#04 REVERSE POLARITY?)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    for (int i = 0; i<= 6; ++i)
        data.ESC[i] = reverseESC(i,ESC[i], false);  //For now, none of the motor need to be reversed for each motor                                           
    data.ESC[2] = reverseESC(2,ESC[2], true);        //the left middle of robot motor need to be reversed
    data.ESC[5] = reverseESC(5,ESC[5], true);        //the right middle of robot motor need to be reversed
   
    ////////////////////////////////////////////////////////////////(If Statements: Errors)//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (racing == true) {
      lcd.setCursor (3, 2);
      lcd.print("              ");
    }
    else if (racing == false) {
      clearMotors_LCD();                                             //not in racing mode so clear the ESC positions printed on the LCD
    }
    else 
      stop();
    
    ///////////////////////////////////////////////////////////////////////(END)/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    radio.write( &data, sizeof(controllerData) );                  //send all this data to the reciever where the reciever will then supply the motors with the code to go
    if (!radio.write( &data, sizeof(controllerData) ))             //if it fails to send, reset the data to all neutral pulses
    {
      Serial.print("failed!    ");
      stop();
      lcd.setCursor (0, 3);
      lcd.print("FAILx");
    }//end of "if sending fails" test statement 

    if (data.climbing_sw == 0){
      print_SpeedPot_onLCD(speedPot);                              //too many conflicts in the 2nd row of the LCD, this statement makes things work out
    }     
    Serial.print("SpeedPot: ");
    Serial.print(speedPot);
    Serial.print("    ");   
    if (printCalib == 1){
      Serial.print("C4 LX1: ");    Serial.print(ESC_X[1]);          //will print the lastest ESC value when we r testing (can ignore this part)
      Serial.print("   ");
      Serial.print("C4 RY1: ");    Serial.print(ESC_Y[1]);
      Serial.print("         ");
    }
    if (radio.write(&data, sizeof(controllerData)))              //if it successfully sends the data, let me know exactly whats going out to each motor
    { 
      print_defaultStick_y_onLCD();                                //print the default stick so we will know if the sticks r stable
      if (racing == 1) {                                         //if its racing/climbing/stop MODE, print all the motors.
        outgoing_leftMotors_LCD();
        outgoing_rightMotors_LCD();
      }
    }//end of writing to reciever 
    print_ALL_OUTGOINGS_onSerialMonitor();                       //prints exactly whats going out to each ESC
    printCalib = 0;                                                                       
  }//end of else statement    
  Serial.println();
}//End of program
